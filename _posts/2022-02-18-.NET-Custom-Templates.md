---
layout:     post
title:      .NET Core / 6 Custom Templates
date:       2022-02-18
summary:    A lap around .NET Core Custom templating engine.
categories: .NET, Custom Templates 
---

On one of my recent projects around serverless, we were creating lots of microservices and each microservice was its own Visual Studio Solution. Since there were lots of dev teams involved building these services, we wanted to standardize on a solution structure which could be easily adopted across different teams. 

We were looking to automate the scaffolding of these solutions, so that devs across these different teams could quickly and easily create consistent solutions and this is where we started looking at [Custom .NET Templates](https://docs.microsoft.com/en-us/dotnet/core/tools/custom-templates).

If you read through the previous link, you can see that the custom templating engine has been significantly evolved since .NET core 2 and its now relatively very easy to create custom templates.

***NOTE: There is lots to the custom templating engine, however in this post we will see how we leveraged some of those features relevant to our use case***

Now, our solutions were following a very consistent structure, a close example of which is shown below:

~~~text
Microservice.sln
│   .editorconfig
|
└───Documentation
    ├───Wiki
    |
└───Source
    ├───Service.csproj  
        │   Startup.cs
    |  
    └───Shared
        ├───Domain.csproj
    |
 └───Testing
    ├───IntegrationTest.csproj 
        │   Program.cs
    |  
    ├───UnitTest.csproj 
~~~

***Documentation*** folder contained all the relevant documentation related to that Microservice.

***Source*** folder as the name indicates, contained the actual ***Service*** as the Azure Function project and ***Shared*** folder contained a class library for encapsulating domain logic.

***Testing*** folder contained ***IntegrationTest*** console project and ***UnitTest***, as a standard MSTest project.

These solutions also followed a naming convention such as {Company}.{Application}.{Component}.{name}.csproj and therefore when scaffolded, had to have the ability to inidicate those.  

OK, so in order to get started, my first step was to create this kind solution structure and templatize the variables which could be substituted when the final solution was created. This was all accomplished via the [template.json](https://github.com/AdiThakker/Azure.Function.Template/blob/main/templates/Azure.FunctionServiceTemplate.Scaffolding/.template.config/template.json) which is included under the ***.template.config*** folder of the source code.

I have shown that file below for our review and will go over some the relevant symbols generators. If you want to understand all of the replacements, [this](https://github.com/dotnet/templating/wiki/Reference-for-template.json) reference does a pretty good job and i would encourage you to read that.  

~~~json
{
  "$schema": "http://json.schemastore.org/template",
  "author": "Adi Thakker",
  "classifications": [ "Solution", "Service" ],
  "identity": "Adi.FunctionAppTemplate.CSharp",
  "name": "Adi Thakker Custom function app template",
  "shortName": "adifunctionappservice",
  "tags": {
    "language": "C#",
    "type": "solution"
  },
  "symbols": {
    "company": {
      "type": "parameter",
      "isRequired": true,
      "datatype": "text",
      "replaces": "Company",
      "defaultValue": "Your Company name",
      "fileRename": "Company"
    },
    "application": {
      "type": "parameter",
      "isRequired": true,
      "datatype": "text",
      "replaces": "Application",
      "defaultValue": "Your Application name",
      "fileRename": "Application"
    },
    "component": {
      "type": "parameter",
      "isRequired": true,
      "datatype": "text",
      "replaces": "Component",
      "defaultValue": "Your Component name",
      "fileRename": "Component"
    },
    "includeIntegrationTest": {
      "type": "parameter",
      "datatype": "bool",
      "defaultValue": "true"
    }
  },
  "sources": [
    {
      "modifiers": [
        {
          "condition": "(!includeIntegrationTest)",
          "exclude": [ "Testing/Company.Application.Component.IntegrationTest/**" ]
        }
      ]
    }
  ],
  "preferNameDirectory": true
}
~~~

OK, so few of the key elements are:


***classifications***, this is used to classify our template type when creating a solution of that type.

***shortname***, this value is used with ***dotnet new*** command when generating solution of that type.

***symbols*** are used to tokenize and substitute the variables for solution naming convention.

Also specified is ***includeIntegrationTest*** symbol for conditionally generating the integrationtest.csproj since not every solution needs that and the ***sources.modifiers*** section checks for that value to include/exclude that in the scaffolding.

OK, so in order to test this, the next step was to install the template locally via: 

~~~cmd
dotnet new --install <PATH_TO_FOLDER_CONTAINING_TEMPLATE.CONFIG_FOLDER>
~~~

![image]({{site.url}}/images/custom-template-1.png)

We can verify the successful installation via : It should show up in the list of installed templates

~~~cmd
dontnet new --list
~~~

![image]({{site.url}}/images/custom-template-2.png)



Now actual creation

~~~
dotnet new 
~~~

Once the parameters we supplied.

The final output...

This technique has really expedited our consistent microservice creation you can export this into a NuGet package by 
updating the .csproj file

~~~
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <PackageType>Template</PackageType>
    <PackageVersion>1.0.0</PackageVersion>
    <PackageId>My Custom Azure Function Template</PackageId>
    <Title>Azure Function Template</Title>
    <Authors>Adi Thakker</Authors>
    <Description>Solution Template that scaffolds a custom Azure Function Microservice Projects</Description>
    <TargetFramework>net6.0</TargetFramework>
    <IncludeContentInPack>true</IncludeContentInPack>
    <IncludeBuildOutput>false</IncludeBuildOutput>
    <ContentTargetFolders>content</ContentTargetFolders>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <NoDefaultExcludes>true</NoDefaultExcludes>
    <PackageOutputPath>./nupkg</PackageOutputPath>
    <PackageType>function-app;microservice;service</PackageType>
  </PropertyGroup>

  <ItemGroup>
    <Content Include="templates\**\*" Exclude="templates\**\bin\**;templates\**\obj\**" />
    <Compile Remove="**\*" />
  </ItemGroup>
  
</Project>
~~~

The entire code is available here, if you want to explore the details:











